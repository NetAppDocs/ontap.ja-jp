---
permalink: flexcache-writeback/flexcache-write-back-architecture.html 
sidebar: sidebar 
keywords: tr-4743, flexcache writeback, flexcache write-back, flexcache, write-back, write back, lock delegations, data delegations, dirty data, cache scrubbers, disconnected mode, grok it, sequence diagrams, technical report, netapp tr, ontap tr 
summary: FlexCacheライトバックの動作の詳細を理解します。 
---
= FlexCacheライトバックアーキテクチャ
:allow-uri-read: 


[role="lead"]
FlexCacheは、ライトバックモードとライトアラウンドモードの両方を含め、高い整合性を考慮して設計されています。ONTAP 9.15.1で導入された従来のライトアラウンド処理モードと新しいライトバック処理モードはどちらも、アクセスされるデータの整合性、最新性、一貫性を常に100%保証します。

次の概念では、FlexCacheライトバックの動作について詳しく説明します。



== 委譲

委譲とデータ委譲をロックすると、FlexCacheはライトバックキャッシュとライトアラウンドキャッシュの両方で、データの整合性、一貫性、最新の状態を維持できます。オリジンが両方の委譲をオーケストレーションします。



=== ロックイジョウ

ロックの委譲は、必要に応じてクライアントにプロトコルロックを発行するために、送信元がキャッシュにファイル単位で付与するプロトコルレベルのロック権限です。これらにはおよびが含まれます xref:flexcache-write-back-overview.html#flexcache-write-back-terminology[排他ロック委任(XLD)] xref:flexcache-write-back-overview.html#flexcache-write-back-terminology[共有ロック委譲（SLD）]。

.XLDおよびライトバック
ONTAPが競合する書き込みを調整する必要がないようにするために、クライアントがファイルへの書き込みを要求するキャッシュにXLDが付与されます。重要なことは、一度に1つのファイルに対して1つのXLDしか存在できないことです。つまり、1つのファイルに対して複数のライタが存在することはありません。

ファイルへの書き込み要求がライトバックが有効なキャッシュに入ると、次の手順が実行されます。

. キャッシュは、要求されたファイルのXLDがすでに存在しているかどうかをチェックします。その場合、別のクライアントがキャッシュにあるファイルに書き込んでいない限り、書き込みロックがクライアントに付与されます。キャッシュに要求されたファイルのXLDがない場合、キャッシュはオリジンからXLDを要求します。これは、クラスタ間ネットワークを経由する独自のコールです。
. キャッシュからXLD要求を受信すると、オリジンはファイルの未処理のXLDが別のキャッシュにあるかどうかをチェックします。その場合、そのファイルのXLDが呼び出され、そのキャッシュからオリジンへのフラッシュがトリガーされ xref:flexcache-write-back-overview.html#flexcache-write-back-terminology[ダーティーデータ] ます。
. そのキャッシュのダーティデータがフラッシュバックされ、オリジンの安定したストレージにコミットされると、オリジンはファイルのXLDを要求元のキャッシュに付与します。
. ファイルのXLDを受信すると、キャッシュによってクライアントにロックが許可され、書き込みが開始されます。


これらの手順の一部を網羅する高レベルのシーケンス図をシーケンス図で説明します <<write-back-sequence-diagram>> 。

クライアント側では、すべてのロックは標準のFlexVolまたはFlexGroupに書き込みを行っているかのように機能し、書き込みロックが要求されたときにわずかな遅延が発生する可能性があります。

現在のイテレーションでは、ライトバックが有効なキャッシュがファイルのXLDを保持している場合、ONTAPは操作を含む他のキャッシュでそのファイルへの*すべての*アクセスをブロックします `READ` 。


NOTE: オリジンコンスティチュエントあたりのXLD数は170に制限されています。



=== データ委譲

データ委譲は、送信元がそのファイル用にキャッシュされたデータが最新であることをキャッシュに付与するファイル単位の保証です。キャッシュにファイルのデータ委譲があるかぎり、そのファイルのキャッシュデータをクライアントに提供できます。元のファイルにアクセスする必要はありません。キャッシュにファイルのデータ委任がない場合は、クライアントから要求されたデータを受信するためにオリジンに接続する必要があります。

ライトバックモードでは、ファイルのデータ委譲は、そのファイルのXLDが別のキャッシュまたはオリジンで取得された場合に取り消されます。これにより、読み取り時も含め、他のすべてのキャッシュとオリジンでクライアントからファイルが実質的に遮断されます。これはトレードオフであり、古いデータにアクセスしないようにする必要があります。

ライトバックが有効なキャッシュでの読み取りは、一般にライトアラウンドキャッシュでの読み取りと同様に処理されます。ライトアラウンドキャッシュとライトバックが有効なキャッシュの両方で、要求されたファイルが、読み取りが発行された場所以外のライトバックが有効なキャッシュで排他的な書き込みロックを持つと、初期パフォーマンスが低下する可能性があります `READ` 。XLDを取り消す必要があり、他のキャッシュでの読み取りを処理する前に、ダーティデータをオリジンにコミットする必要があります。



== ダーティーデータの追跡

キャッシュからオリジンへのライトバックは非同期的に行われます。これは、ダーティデータがすぐにオリジンに書き戻されるわけではないことを意味します。ONTAPでは、ダーティデータレコードシステムを使用して、ファイルごとにダーティデータを追跡しています。各ダーティデータレコード（DDR）は、特定のファイルの約20MBのダーティデータを表します。ファイルがアクティブに書き込まれている場合、ONTAPは2つのDDRがいっぱいになり、3つ目のDDRが書き込まれると、ダーティデータのフラッシュを開始します。その結果、書き込み中にキャッシュ内に約40MBのダーティデータが残ります。ステートフルプロトコル（NFSv4.x、SMB）の場合、ファイルを閉じると、残りの40MBのデータが元のボリュームにフラッシュされます。ステートレスプロトコル（NFSv3）の場合、ファイルへのアクセスが別のキャッシュで要求されたとき、またはファイルが2分以上アイドル状態になったあと（最大5分）に、40MBのデータがフラッシュバックされます。タイマートリガー型またはスペーストリガー型ダーティデータフラッシュの詳細については、を参照してください <<キャッシュスクラビング>>。

DDRとスクラバーに加えて、一部のフロントエンドNAS操作では、ファイルのすべてのダーティデータのフラッシュもトリガーされます。

* `SETATTR`
+
** mtime、atime、ctimeのみを変更するsetattrはキャッシュで処理できるため、WANのペナルティを回避できます。


* `CLOSE`
* `OPEN` 別のキャッシュ
* `READ` 別のキャッシュ
* `READDIR` 別のキャッシュ
* `READDIRPLUS` 別のキャッシュ
* `WRITE` 別のキャッシュ




== 切断モード

ファイルのXLDがライトアラウンドキャッシュに保持され、そのキャッシュがオリジンから切断された場合でも、そのファイルの読み取りは他のキャッシュおよびオリジンで引き続き許可されます。この動作は、XLDがライトバックが有効なキャッシュに保持されている場合に異なります。この場合、キャッシュが切断されている場合、ファイルへの読み取りはどこでもハングします。これにより、100%の一貫性、通貨、一貫性が維持されます。クライアントに書き込み確認応答されたすべてのデータが元のボリュームに確実に格納されるため、読み取りはWrite-aroundモードで許可されます。切断中のライトバックモードでは、切断前にライトバックが有効なキャッシュに書き込まれて確認されたすべてのデータがオリジンに送信されたことをオリジンが保証することはできません。

ファイルのXLDを持つキャッシュが長時間切断された場合、システム管理者はオリジンでXLDを手動で取り消すことができます。これにより、ファイルへのIOが、サバイバーキャッシュとオリジンで再開されます。


WARNING: XLDを手動で取り消すと、切断されたキャッシュにあるファイルのダーティデータが失われます。XLDの手動取り消しは、キャッシュとオリジンの間で壊滅的な中断が発生した場合にのみ実行してください。



== キャッシュスクラビング

ONTAPには、タイマーの期限切れやスペースのしきい値超過など、特定のイベントに応じて実行されるスクラバーがあります。スクラバーは、スクラビングされているファイルに対して排他ロックを取得し、スクラビングが完了するまで、そのファイルへのIOを事実上凍結します。

スクラバーには以下が含まれます。

* *キャッシュ上のmtimeベースのスクラビング：*このスクラビングは5分ごとに開始され、変更されていないファイルを2分間スクラビングします。ファイルのダーティーデータがキャッシュに残っている場合、そのファイルへのIOは休止され、ライトバックがトリガーされます。IOはライトバックの完了後に再開されます。
* * mtimeベースのscrubber on origin：*キャッシュにあるmtimeベースのscrubberと同様に、これも5分ごとに実行されます。ただし、変更されていないファイルは15分間スクラビングされ、inodeの委譲が呼び出されます。このスクラバーはライトバックを開始しません。
* * RW制限ベースのオリジンスクラバー：* ONTAPは、オリジンコンスティチュエントごとに配布されるRWロック委譲の数を監視します。この数が170を超えると、ONTAPはLeast-Recently-Used（LRU）ベースで書き込みロック委譲のスクラビングを開始します。
* *キャッシュ上のスペースベーススクラビング：* FlexCacheボリュームの使用率が90%に達すると、キャッシュはスクラビングされ、LRUベースで削除されます。
* *元のスペースベーススクラビング：* FlexCache元のボリュームの使用率が90%に達すると、キャッシュはスクラビングされ、LRUベースで削除されます。




== シーケンス図

これらのシーケンス図は、ライトアラウンドモードとライトバックモードの間の書き込み確認応答の違いを示しています。



=== ライトアラウンド

image::flexcache-write-around-sequence-diagram.png[FlexCache Write-Aroundシーケンス図]



=== ライトバック

image::flexcache-write-back-sequence-diagram.png[FlexCache -ライトバックシーケンスの図]
